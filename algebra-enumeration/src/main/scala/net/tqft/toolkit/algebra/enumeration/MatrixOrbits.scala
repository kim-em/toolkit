package net.tqft.toolkit.algebra.enumeration

import scala.annotation.tailrec
import net.tqft.toolkit.arithmetic.Mod._

object MatrixOrbits extends App {

  // matrix_string should be the inverse transpose of hombasis, from UCT
  case class ConditionData(n: Int, matrix_string: String) {
    private val r = matrix_string.toCharArray.takeWhile(_ != '}').count(_ == ',') + 1
    val matrix = matrix_string.replaceAll("[{} ]", "").split(",").grouped(r).map(r => r.map(_.toInt)).toArray
    val matrix_packed = matrix.map(r => pack(r, 1))
  }

  //   // A test case
  //    val n = 3
  //    val b = 1
  //    val matrices_string = "[[[0,1,0],[1,0,0],[0,0,1]]]"
  //    val condition: Option[ConditionData] = None

  // SmallGroup(8,5)
  //  val n = 7
  //  val b = 1
  //  val matrices_string = "[[[1,0,0,0,0,0,0],[1,1,0,2,0,0,0],[0,0,1,0,0,0,0],[1,0,0,1,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,1,0,1]],[[0,1,0,0,0,0,0],[0,0,1,0,0,0,0],[1,0,0,0,0,0,0],[0,0,0,0,0,1,0],[0,0,0,1,0,0,0],[0,0,0,0,1,0,0],[0,0,0,0,0,0,1]]]"
  //  val condition: Option[ConditionData] = None

  // SmallGroup(16,14)
  //    val n = 14
  //    val b = 1
  //    val matrices_string= "[[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,2,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1]],[[0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0]]]"
  //    val condition: Option[ConditionData] = None

  //  // SmallGroup(32, 51)
  val n = 25
  val b = 1
  val matrices_string = "[[[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]],[[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0]]]"
  val condition: Option[ConditionData] = None

  //  // SmallGroup(32,45)
  //  val n = 14
  //  val b = 2
  //  val matrices_string = "[[[1,1,1,2,2,2,2,4,4,4,0,0,0,0],[0,1,1,0,0,0,2,0,0,0,0,0,0,0],[1,1,0,0,2,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,1,1,2,0,2,2,0,0,0,0],[1,1,0,0,2,1,1,2,2,0,0,0,0,0],[0,1,0,0,1,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,1,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,-1,-1,0],[0,0,0,0,0,0,0,0,2,0,-1,-1,-1,0],[0,1,0,0,1,0,1,0,2,0,-1,-1,-1,-1]],[[1,1,0,2,2,0,0,4,4,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,0,2,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,1,0,0,2,0,0,0,0],[0,1,0,0,1,1,1,0,2,2,0,0,0,0],[0,0,1,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,1,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,-2,0,1,1,0],[0,0,0,0,0,0,0,0,0,-2,1,1,1,0],[0,0,0,0,0,0,0,0,0,2,0,0,-1,0],[0,0,0,0,0,1,0,0,0,2,0,0,-1,-1]],[[1,0,0,2,0,0,0,4,0,0,0,0,0,0],[0,1,0,2,0,0,0,0,4,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,2,1,0,0,2,2,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,2,0,0,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0],[0,0,0,1,0,0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,2,0,0,0,2,-2,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,-2,0,1,0,0],[0,0,0,0,0,0,0,0,0,-2,0,0,1,0],[0,0,0,0,0,0,0,0,0,2,0,-1,1,1]],[[1,0,0,2,0,0,0,4,0,0,0,0,0,0],[0,1,0,2,0,0,0,0,4,0,0,0,0,0],[0,0,1,2,0,0,0,0,0,4,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,2,1,0,0,2,2,0,0,0,0,0],[0,0,0,2,0,1,0,2,0,2,0,0,0,0],[0,0,0,2,0,0,1,0,2,2,0,0,0,0],[0,0,0,1,0,0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,1,0,0,0,0],[0,0,0,2,0,0,0,2,-2,0,1,0,0,0],[0,0,0,2,0,0,0,2,0,-2,0,1,0,0],[0,0,0,2,0,0,0,0,2,-2,0,0,1,0],[0,0,0,2,0,0,0,2,-2,2,1,-1,1,1]],[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,2,0,0,0,0,4,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,2,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,2,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,2,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,-2,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,-1,0,1]],[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,3,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,3,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,3,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,3,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,3,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,3,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1]],[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[2,0,0,1,0,0,0,4,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,0],[0,0,0,0,-2,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,-2,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,2],[0,0,0,0,0,0,0,0,0,0,0,0,0,1]],[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,2,0,1,0,0,0,0,4,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,1,0,0,0,0],[0,0,0,0,2,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,-2],[0,0,0,0,0,0,-2,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1]],[[1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,2,1,0,0,0,0,0,4,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,2],[0,0,0,0,0,2,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,2,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1]]]"
  //  val condition: Option[ConditionData] = Some(ConditionData(n, "{{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, -2, 3, -3, 3, -3, 3, -3, 3, -3, 3, -3}, {0, 0, 0, 0, 0, 1, -1, 1, -1, 1, -1, 1, -1, 1}, {0, 0, 0, -2, 2, -2, 3, -3, 3, -3, 3, -3, 3, -3}, {0, 0, 0, 0, 0, 0, 0, 1, -1, 1, -1, 1, -1, 1}, {0, 0, 0, -2, 2, -2, 2, -2, 3, -3, 3, -3, 3, -3}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 1, -1, 1}, {0, 0, 0, -2, 2, -2, 2, -2, 2, -2, 3, -3, 3, -3}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 1}, {0, 0, 0, -2, 2, -2, 2, -2, 2, -2, 2, -2, 3, -3}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}, {0, 0, 0, 2, -2, 2, -2, 2, -2, 2, -2, 2, -2, 2}}"))

  val e = scala.math.pow(2, b).toInt
  val L = scala.math.pow(e, n).toInt

  val matrices = matrices_string.replaceAllLiterally("[", "").replaceAllLiterally("]", "").split(",").grouped(n * n).toArray.map(_.grouped(n).toArray.map(r => r.map(x => x.toInt mod e)))

  def pack(row: Array[Int], base: Int = b): Int = {
    var r = 0
    for (x <- row) {
      r = (r << base) + x
    }
    r
  }
  val matrices_packed = matrices.map(m => m.map(r => pack(r)))

  @tailrec
  def countOnes_(x: Int, r: Int): Int = {
    if (x == 0) {
      r
    } else {
      countOnes_(x / 2, (r + x) % 2)
    }
  }
  lazy val countOnes = Array.tabulate(L)(i => countOnes_(i, 0))

  def dot(a: Int, b: Int, modulus: Int = e) = {
    @tailrec
    def dot_(a: Int, b: Int, r: Int): Int = {
      if (a == 0) {
        r
      } else {
        dot_(a / modulus, b / modulus, (r + a * b) % modulus)
      }
    }
    dot_(a, b, 0)
  }

  def action(x: Int): Array[Int] = {
    if (e == 2) {
      for (m <- matrices_packed) yield {
        pack(for (r <- m) yield countOnes(r & x))
      }
    } else {
      for (m <- matrices_packed) yield {
        pack(for (r <- m) yield dot(r, x))
      }
    }
  }

  def allowed(x: Int): Boolean = {
    condition match {
      case None    => true
      case Some(m) => m.matrix_packed.forall(r => dot(r, x, m.n) == 0)
    }
  }

  val components = Array.fill(L.toInt)(0)
  var i = 0
  var m = 0
  var c = 1
  val componentsAllowed = scala.collection.mutable.ListBuffer[Boolean]()
  while (i < L) {
    if (components(i) == 0) {
      // we haven't computed the component of this one yet

      val a = allowed(i)
      println(c + ": " + m + "/" + L + " " + a)

      componentsAllowed += a

      val stack = scala.collection.mutable.Stack[Int](i)
      components(i) = c
      m = m + 1
      while (stack.nonEmpty) {
        val j = stack.pop
        for (k <- action(j) if components(k) == 0) {
          components(k) = c
          m = m + 1
          stack.push(k)
        }
      }
      c = c + 1
    }
    i = i + 1
  }
  // Now output representatives
  @tailrec
  def carryDigits(n: Int, carry: List[Int]): List[Int] =
    if (n < e) n :: carry
    else carryDigits(n / e, (n % e) :: carry)
  def digits(i: Int): List[Int] = carryDigits(i, List())
  def unpack(i: Int) = digits(i).reverse.padTo(n, 0).reverse.mkString("[", ", ", "]")

  i = 0
  var d = 1
  while (i < L && d <= c) {
    if (components(i) == d) {
      if (componentsAllowed(d - 1)) {
        println(unpack(i))
      }
      d = d + 1
    }
    i = i + 1
  }
}