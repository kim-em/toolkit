(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



DeclarePackage["Spiders`Trivalent`",{"Trivalent","SO3Categories","dMinusOne","SO3","CubicTrivalentCategories","CubicTrivalentCategory","G2Categories","ABACategories","PickledG2"}];
DeclarePackage["Spiders`BraidedTrivalent`",{"BraidedTrivalent","SymmetricTrivalent","BraidedSO3Categories","CubicBraidedTrivalentCategories","CubicBraidedTrivalent","BraidedG2Categories"}];


Print[
"Loading Spiders` version 2015-06-18 ..."
]


BeginPackage["Spiders`",{"JLink`","GuessingPolynomials`"}];


h;t;d;z;


ScalaSingleton;ScalaCaseClass;FromScalaObject;AsScalaObject;


Diagram;NamedPolyhedron;PlanarGraphs;polygon;Name;DrawPlanarGraph;DrawReducingRelations;DrawRelations


unionDiagrams;complementDiagrams;memberQDiagrams;


SaveGroebnerCalculations;LoadGroebnerCalculations;


IntroduceNewVariable;


Manifold;DeclarePolynomialZero;DeclarePolynomialsZero;DeclareAtLeastOnePolynomialZero;DeclarePolynomialNonZero;DeclarePolynomialsNonZero;DeclarePolynomialEitherZeroOrNonZero;


DeclareDimensionBounds;DimensionBounds;DimensionLowerBound;DimensionUpperBound;


p;tt;


IndependentDiagrams;DependentDiagrams;SpanningSets;ReducingRelations;NonReducingRelations;AppendIndependentDiagram;AppendDependentDiagram;AppendClosedDiagram;ReducedDiagrams;ReducibleDiagrams;


SpiderAnalysis;buildSpiderAnalysis;FreeSpider;emptySpiderAnalysis;


internalValences;diagramWeight;


EvaluateDiagram;EvaluateClosedDiagram;


ClosedDiagrams;ConsiderClosedDiagram;ConsiderClosedDiagrams;ReconsiderClosedDiagrams;


ConsiderPotentialSpanningSet;DeclareSpanningSet;DeclareBasis;ConsiderDiagrams;ConsiderDiagram;ConsiderIndependentDiagram;ConsiderDependentDiagram;IntroduceRelation;


PairRelationsWith;ReducePolynomials;ReducePolynomialsFurther;


PickleSpiderAnalysis;UnpickleSpiderAnalysis;PickledSpiderAnalysis;PickledQuotientSpider;


Begin["`Private`"];


SpidersMathematicaDirectory=FileNames[Cases[$Path~Join~(Quiet[{NotebookDirectory[]}]/.$Failed->{}),s_/;StringMatchQ[s,__~~"toolkit/algebra-spiders/src/main/mathematica"~~___]]][[1]];


SpidersDirectory=FileNameJoin[{SpidersMathematicaDirectory,"..","..",".."}];


ScalaMajorVersion="2.11";


AddToClassPath[FileNames[ToFileName[{SpidersDirectory,"target","scala-"<>ScalaMajorVersion,"classes"},"log4j.xml"]]];
AddToClassPath[FileNames[ToFileName[{SpidersDirectory,".."},"*/target/scala-"<>ScalaMajorVersion<>"/*.jar"]]];
AddToClassPath[FileNames[ToFileName[{SpidersDirectory,"..","lib_managed","jars"},"*/*/*.jar"]]];
AddToClassPath[FileNames[ToFileName[{SpidersDirectory,"..","lib_managed","bundles"},"*/*/*.jar"]]];
AddToClassPath[FileNames[{ToFileName[{SpidersDirectory,"target","scala-"<>ScalaMajorVersion},"*.jar"]}]];


ScalaSingleton[className_String]:=Module[{},
LoadJavaClass[className<>"$"];
Symbol[StringReplace[className,"."->"`"]<>"$`MODULE$"]
]


ScalaCaseClass[className_String,arguments___]:=Module[{o,applyTypes,a},
LoadJavaClass[className<>"$"];
o=Symbol[StringReplace[className,"."->"`"]<>"$`MODULE$"];
applyTypes=Flatten[StringCases[#,className~~" apply("~~types__~~")":> StringSplit[types,", "]]&/@StringSplit[o//Methods//ToString,"\n"],1];
a=If[Length[applyTypes]==1,
AsScalaObject@@#&/@Transpose[{{arguments},applyTypes[[1]]}],
AsScalaObject/@arguments];
o@apply[Sequence@@a]
]


LoadJavaClass["scala.collection.immutable.List$","AllowShortContext"->False];
LoadJavaClass["scala.collection.immutable.Set$","AllowShortContext"->False];
LoadJavaClass["scala.collection.immutable.Map$","AllowShortContext"->False];
LoadJavaClass["scala.Some$","AllowShortContext"->False];
LoadJavaClass["scala.None$","AllowShortContext"->False];
LoadJavaClass["java.util.Arrays","AllowShortContext"->False];
LoadJavaClass["scala.collection.JavaConversions","AllowShortContext"->False];


Clear[FromScalaObject]


FromScalaObject[o_,0]:=o


FromScalaObject[o_/;!JavaObjectQ[o],depth:_?Positive:\[Infinity]]:=o


FromScalaObject[o_?JavaObjectQ/;InstanceOf[o,"scala.collection.Traversable"],depth:_?Positive:\[Infinity]]:=FromScalaObject[JavaConversions`seqAsJavaList[o@toList[]],depth]
FromScalaObject[o_?JavaObjectQ/;InstanceOf[o,"java.util.List"],depth:_?Positive:\[Infinity]]:=FromScalaObject[#,depth-1]&/@(o@toArray[])
FromScalaObject[o_?JavaObjectQ/;InstanceOf[o,"scala.Tuple2"],depth:_?Positive:\[Infinity]]:=FromScalaObject[#,depth-1]&/@{o@U1[],o@U2[]}


FromScalaObject[o_?JavaObjectQ/;InstanceOf[o,"net.tqft.toolkit.algebra.Fraction"],depth:_?Positive:\[Infinity]]:=FromScalaObject[o@numerator[],depth-1]/FromScalaObject[o@denominator[],depth-1]


latch[f_]:=(latch[f]=False;True)


FromScalaObject[o_?JavaObjectQ/;InstanceOf[o,"net.tqft.toolkit.algebra.polynomials.RationalExpression"],depth:_?Positive:\[Infinity]]:=Module[{result},
result=ToExpression[rationalExpressionMathematicaForm@toMathematicaInputString[o]]/.{q_Symbol/;StringMatchQ[SymbolName[q],"p"~~DigitCharacter..]:>Subscript[p, ToExpression[StringDrop[SymbolName[q],1]]],t0_Symbol/;StringMatchQ[SymbolName[t0],"t"~~DigitCharacter..]:>tt[ToExpression[StringDrop[SymbolName[t0],1]]]};
(*If[latch[o@toString[]],Print["interpreting ",o@toString[], " with mathematica form ",rationalExpressionMathematicaForm@toMathematicaInputString[o], " as ",result]];*)
result
]


FromScalaObject[o_?JavaObjectQ,depth:_?Positive:\[Infinity]]:=o@toString[]


bigIntMathematicaForm=ScalaSingleton["net.tqft.toolkit.algebra.mathematica.MathematicaForm$BigIntMathematicaForm"];
bareStringMathematicaForm=ScalaSingleton["net.tqft.toolkit.algebra.mathematica.MathematicaForm$BareStringMathematicaForm"];


bigRationalMathematicaForm=ScalaSingleton["net.tqft.toolkit.algebra.mathematica.MathematicaForm"]@fractionMathematicaForm[bigIntMathematicaForm,ScalaSingleton["net.tqft.toolkit.algebra.BigIntegers"]];


rationalExpressionMathematicaForm=ScalaSingleton["net.tqft.toolkit.algebra.mathematica.MathematicaForm"]@rationalExpressionMathematicaForm2[bigRationalMathematicaForm,bareStringMathematicaForm];


Clear[AsScalaObject]


AsScalaList[list:{__Integer}]:=scala`collection`JavaConversions`asScalaBuffer[java`util`Arrays`asList[MakeJavaObject/@list]]@toList[]
AsScalaList[list:{__Real}]:=scala`collection`JavaConversions`asScalaBuffer[java`util`Arrays`asList[MakeJavaObject/@list]]@toList[]
AsScalaList[list:{__List}]:=AsScalaList[AsScalaList/@list]
AsScalaList[list_List]:=Fold[#1@$colon$colon[#2]&,ScalaSingleton["scala.collection.immutable.Nil"],Reverse[list]]
AsScalaList[{}]:=scala`collection`immutable`List$`MODULE$@empty[]


AsScalaObject[x_]:=AsScalaObject[x,"Object"]


AsScalaObject[i_Integer,"Object"]:=MakeJavaObject[i]
AsScalaObject[i_Integer,"int"]:=i
AsScalaObject[i_Integer,"java.math.BigInteger"]:=JavaNew["java.math.BigInteger",ToString[i]]


AsScalaObject[o_?JavaObjectQ,_]:=o


AsScalaObject[rules:{__Rule},"Object"|"scala.collection.immutable.Map"]:=AsScalaMap[rules]
AsScalaObject[rules:{___Rule},"scala.collection.immutable.Map"]:=AsScalaMap[rules]
AsScalaMap[rules:{___Rule}]:=ScalaCaseClass["scala.collection.immutable.Map",AsScalaList[{}]]@$plus$plus[AsScalaList[ScalaCaseClass["scala.Tuple2",Sequence@@#]&/@rules]]


Fraction=ScalaSingleton["net.tqft.toolkit.algebra.Fraction"];


Ring=ScalaSingleton["net.tqft.toolkit.algebra.spiders.examples.QuantumExceptionalSeries"]@ring[];


BigIntegers=ScalaSingleton["net.tqft.toolkit.algebra.BigIntegers"];


AsScalaObject[x_Plus,"MultivariableRationalFunction"]:=Ring@sum[AsScalaList[AsScalaObject[#,"MultivariableRationalFunction"]&/@(List@@x)]]
AsScalaObject[x_Times,"MultivariableRationalFunction"]:=Ring@product[AsScalaList[AsScalaObject[#,"MultivariableRationalFunction"]&/@(List@@x)]]
AsScalaObject[Power[x_,k_Integer],"MultivariableRationalFunction"]:=Ring@power[AsScalaObject[x,"MultivariableRationalFunction"],k]
AsScalaObject[x_Integer,"MultivariableRationalFunction"]:=Ring@fromBigInteger[AsScalaObject[x,"java.math.BigInteger"]]
AsScalaObject[x_Rational,"MultivariableRationalFunction"]:=Ring@quotient[AsScalaObject[Numerator[x],"MultivariableRationalFunction"],AsScalaObject[Denominator[x],"MultivariableRationalFunction"]]
AsScalaObject[Subscript[p, k_Integer],"MultivariableRationalFunction"]:=AsScalaObject["p"<>ToString[k],"MultivariableRationalFunction"]
AsScalaObject[tt[k_Integer],"MultivariableRationalFunction"]:=AsScalaObject["t"<>ToString[k],"MultivariableRationalFunction"]
AsScalaObject[x_,"MultivariableRationalFunction"]:=AsScalaObject[x,"MultivariableRationalFunction"]=
ScalaCaseClass["net.tqft.toolkit.algebra.polynomials.RationalExpression$variable",MakeJavaObject[ToString[x]]
]


Diagram=_?(JavaObjectQ[#]\[And]InstanceOf[#,"net.tqft.toolkit.algebra.spiders.PlanarGraph"]&);


NamedPolyhedron[Subscript[p, k_]]:=ScalaSingleton["net.tqft.toolkit.algebra.spiders.PolyhedronNamer"]@byName["p"<>ToString[k]]@get[]


PlanarGraphs=ScalaSingleton["net.tqft.toolkit.algebra.spiders.PlanarGraph"];


polygon[n_Integer]:=polygon[n]=PlanarGraphs@polygon[]@apply[AsScalaObject[n,"Object"]]


Name[d0:Diagram]:=FromScalaObject[ScalaSingleton["net.tqft.toolkit.algebra.spiders.examples.BraidedTrivalentSpider"]@evaluate[AsScalaObject[{d0->Ring@one[]}]]]


DrawPlanarGraph$=ScalaSingleton["net.tqft.toolkit.algebra.spiders.DrawPlanarGraph"]@withOutputPath[FileNameJoin[{SpidersMathematicaDirectory,"graphs"}]];


DrawPlanarGraph[g_]/;InstanceOf[g,"net.tqft.toolkit.algebra.spiders.PlanarGraph"]:=Import[DrawPlanarGraph$@createPDF[g]@toString[]]/.{$Failed->g@toString[],{picture_}:>picture}
DrawPlanarGraph[X_List]:=DrawPlanarGraph/@X


DrawPlanarGraph[S_String]:=DrawPlanarGraph[PlanarGraphs@fromString[S]]


DrawPlanarGraph[Subscript[p, k_Integer]]:=DrawPlanarGraph[NamedPolyhedron[Subscript[p, k]]]


DrawReducingRelations[n_Integer][s_SpiderAnalysis]:=(ReducingRelations[n][s][[All,2]])/.{c_,d:Diagram}:>{ReducePolynomialsFurther[s][c],DrawPlanarGraph[d]}//TableForm


DrawRelations[n_Integer][s_SpiderAnalysis]:=(ReducingRelations[n][s][[All,2]]~Join~NonReducingRelations[n][s])/.{c_,d:Diagram}:>{ReducePolynomialsFurther[s][c],DrawPlanarGraph[d]}//TableForm


unionDiagrams[diagrams_]:=Union[{#@toString[],#}&/@(#@canonicalFormWithDefect[]@U1[]&/@diagrams),SameTest->(First[#1]===First[#2]&)][[All,2]]


complementDiagrams[diagrams1_,diagrams2_]:=PlanarGraphs@fromString[#]&/@DeleteCases[#@canonicalFormWithDefect[]@U1[]@toString[]&/@diagrams1,Alternatives@@(#@canonicalFormWithDefect[]@U1[]@toString[]&/@diagrams2)]


memberQDiagrams[diagrams_,diagram_]:=MemberQ[#@canonicalFormWithDefect[]@U1[]@toString[]&/@diagrams,diagram@canonicalFormWithDefect[]@U1[]@toString[]]


cachedGroebnerBasis[ideal_,variables_]:=cachedGroebnerBasis[ideal,variables]=
Module[{result},
(*Print["beginning GroebnerBasis calculation..."];*)
result=GroebnerBasis[ideal,variables];
(*Print["finishing GroebnerBasis calculation..."];*)
result
]
cachedPolynomialReduce[polynomial_,basis_,variables_]:=cachedPolynomialReduce[polynomial,basis,variables]=Module[{result},
(*Print["beginning PolynomialReduce calculation..."];*)
result=PolynomialReduce[polynomial,basis,variables];
(*Print["finishing PolynomialReduce calculation..."];*)
result
]
cachedRationalFunctionReduce[function_,basis_,variables_]:=Module[{t=Together[function]},
cachedPolynomialReduce[Numerator[t],basis,variables][[2]]/cachedPolynomialReduce[Denominator[t],basis,variables][[2]]
]


SaveGroebnerCalculations[]:=(LoadGroebnerCalculations[];
DownValues[cachedGroebnerBasis]=Cases[DownValues[cachedGroebnerBasis],r_/;FreeQ[r,_t]];Put[{DownValues[cachedGroebnerBasis],DownValues[cachedPolynomialReduce]},FileNameJoin[{SpidersMathematicaDirectory,"groebnerCalculations.m"}]])
LoadGroebnerCalculations[]:=Module[{file=FileNameJoin[{SpidersMathematicaDirectory,"groebnerCalculations.m"}],data},
If[FileExistsQ[file],
data=Get[file];
DownValues[cachedGroebnerBasis]=DownValues[cachedGroebnerBasis]~Join~data[[1]];
DownValues[cachedPolynomialReduce]=DownValues[cachedPolynomialReduce]~Join~data[[2]];
]
]


(*SaveGroebnerCalculations[]*)


(*LoadGroebnerCalculations[]*)


timesToList[X_Times]:=List@@X
timesToList[X_]:={X}


withoutMultiplicity[X_^k_]:={X,k};
withoutMultiplicity[X_]:={X,1};


Clear[text]


text[A___]:=text[StringJoin@@(Switch[#,_String,#,_?JavaObjectQ,#@toString[],_,"\("<>ToString[#,TeXForm]<>"\)"]&/@{A})]
text[S_String]:=Print[S]


automaticFlatMap[f_]:=f[a__][Xs_List]:=Union[Flatten[f[a]/@Xs,1]]


automaticFlatMap/@{DeclarePolynomialEitherZeroOrNonZero,DeclarePolynomialsZero,DeclarePolynomialZero,DeclareAtLeastOnePolynomialZero,DeclarePolynomialNonZero,DeclarePolynomialsNonZero,DeclareIrreduciblePolynomialNonZero};


IntroduceNewVariable[v_][X_]:=X/.{m_Manifold:>ReplacePart[m,5->Prepend[m[[5]],v]]}


DeclarePolynomialEitherZeroOrNonZero[polynomial_][m_Manifold]:=Flatten[{DeclarePolynomialZero[polynomial][m],DeclarePolynomialNonZero[polynomial][m]},1]


DeclarePolynomialsZero[polynomials_][m_Manifold]:=Module[{variables,sortedPolynomials},
variables=m[[5]]~Join~Union[Cases[polynomials,Subscript[p, _]|tt[_],\[Infinity]]];
sortedPolynomials=SortBy[polynomials,Function[polynomial,Min[(Exponent[polynomial,#]&/@variables)/.{0->\[Infinity]}]]];
sortedPolynomials=SortBy[polynomials,ByteCount];
Print[sortedPolynomials];
Fold[DeclarePolynomialZero[#2][#1]&,{m},sortedPolynomials]
]


DeclareAtLeastOnePolynomialZero[p_List][m_Manifold]:=Flatten[DeclarePolynomialZero[#][m]&/@p,1]


DeclarePolynomialZero[0][m_Manifold]:={m}
DeclarePolynomialZero[p_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{factors},
If[MemberQ[nonzeroPolynomials~Join~(-nonzeroPolynomials),p],{},
factors=Complement[ReducePolynomials[m]/@Cases[withoutMultiplicity/@timesToList[Factor[ReducePolynomials[m][p]]],{f_,k_}/;k>0:>f],nonzeroPolynomials~Join~(-nonzeroPolynomials)];
If[factors==={0},{m},
factors=DeleteCases[factors,_Integer|_Rational];
If[Length[factors]==0,{},
If[Length[Complement[factors,groebnerBasis~Join~(-groebnerBasis)]]==0,{m},
Print["We find the factors " ,factors," and then require that at least one is zero. "];
Flatten[DeclareIrreduciblePolynomialZero[#][m]&/@factors,1]
]
]
]
]
]


Clear[DeclareIrreduciblePolynomialZero]


DeclareIrreduciblePolynomialZero[polynomial_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{newSubstitutions,variables0},
If[polynomial===0,{m},
If[NumericQ[polynomial]\[Or]MemberQ[nonzeroPolynomials,polynomial],{},
If[FreeQ[polynomial,Subscript[p, _]|tt[_]],
(* this goes into the Groebner basis *)
AddIrreduciblePolynomialToGroebnerBasis[polynomial][m],
(* this goes into the other identities *)
AddIrreduciblePolynomialToOtherIdentities[polynomial][m]
]
]
]
]


AddIrreduciblePolynomialToGroebnerBasis[polynomial_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{linearVariables,newGroebnerBasis,newNonzeroPolynomials,newOtherIdentities,newManifold,newSubstitutions},
newNonzeroPolynomials=Union[Factor[cachedRationalFunctionReduce[#,{polynomial}~Join~groebnerBasis,variables]&/@nonzeroPolynomials]];
newNonzeroPolynomials=Union[newNonzeroPolynomials,Flatten[Cases[withoutMultiplicity/@timesToList[Factor[#]],{f_,k_}:>f]&/@newNonzeroPolynomials]];
If[MemberQ[newNonzeroPolynomials,0],
{},
If[Length[linearVariables=Cases[variables,v_/;Exponent[polynomial,v]==1,1,1]]>0,
Print["solving ",polynomial, " immediately"];
VerifyNonzero[nonzeroPolynomials][FactorGroebnerBasis[SolvePolynomial[polynomial,linearVariables[[1]]][m]],m],
Print["adding ", polynomial," to the Groebner basis ",Short[groebnerBasis]];
newGroebnerBasis=cachedGroebnerBasis[groebnerBasis~Join~{polynomial},variables];
If[MemberQ[newGroebnerBasis,1|-1],{},
Print["newGroebnerBasis: ",newGroebnerBasis];
newOtherIdentities=DeleteCases[cachedPolynomialReduce[#,newGroebnerBasis,variables][[2]]&/@otherIdentities,0];
Print["substitutions: ",substitutions];
newNonzeroPolynomials=Union[Factor[cachedRationalFunctionReduce[#,newGroebnerBasis,variables]&/@newNonzeroPolynomials]];
newNonzeroPolynomials=Union[newNonzeroPolynomials,Flatten[Cases[withoutMultiplicity/@timesToList[Factor[#]],{f_,k_}:>f]&/@newNonzeroPolynomials]];
newManifold=Manifold[substitutions,newGroebnerBasis,newOtherIdentities,newNonzeroPolynomials,variables];
newNonzeroPolynomials=Union[Factor[cachedRationalFunctionReduce[#,newGroebnerBasis,variables]&/@nonzeroPolynomials]];
newNonzeroPolynomials=Union[newNonzeroPolynomials,Flatten[Cases[withoutMultiplicity/@timesToList[Factor[#]],{f_,k_}:>f]&/@newNonzeroPolynomials]];
If[MemberQ[newNonzeroPolynomials,0],{},
newSubstitutions=Function[{subst},
(*Print["updating substitution: ",subst];*)subst[[1]]->ReducePolynomials[newManifold][subst[[2]]]]/@substitutions;
newNonzeroPolynomials=DeleteCases[newNonzeroPolynomials,_Integer|_Rational];
newManifold=Manifold[newSubstitutions,newGroebnerBasis,newOtherIdentities,newNonzeroPolynomials,variables];
VerifyNonzero[nonzeroPolynomials][FactorGroebnerBasis[SolveOtherIdentities[SolveGroebnerBasis[PromoteOtherIdentities[newManifold]]]],m]
]
]
]
]
]


VerifyNonzero[polynomials_][m_Manifold,ms___Manifold]:=If[!And@@(mustBeNonZeroQ[m,#]===True&/@polynomials),
Print["nonzero polynomials seem to have been forgotten!"];
Print[Cases[polynomials,pp_/;!mustBeNonZeroQ[m,pp]]];
Print["manifold: ",m];
If[Length[{ms}]>0,Print["old manifold: ",ms]];
Message[foo::bar];
Abort[],
m
]


VerifyNonzero[polynomials_][m_Manifold,ms___Manifold]:=m


VerifyNonzero[polynomials_][S_List,ms___Manifold]:=VerifyNonzero[polynomials][#,ms]&/@S


FactorGroebnerBasis[m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{targets},
targets=Cases[(withoutMultiplicity/@timesToList[Factor[#]])&/@groebnerBasis,factorization_/;Total[factorization[[All,2]]]>=2,1,1];
If[Length[targets]==0,{m},
FactorGroebnerBasis[VerifyNonzero[nonzeroPolynomials][DeclareAtLeastOnePolynomialZero[targets[[1,All,1]]][m],m]]
]
]
FactorGroebnerBasis[M_List]:=Flatten[FactorGroebnerBasis/@M,1]


PromoteOtherIdentities[m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{targets},
targets=Cases[otherIdentities,e_/;FreeQ[e,Subscript[p, _]|tt[_]]];
If[Length[targets]==0,
{m},
Print["Promoting identities into the Groebner basis: ",targets];
VerifyNonzero[nonzeroPolynomials][DeclarePolynomialsZero[targets][Manifold[substitutions,groebnerBasis,Complement[otherIdentities,targets],nonzeroPolynomials,variables]],m
]]
]
PromoteOtherIdentities[M_List]:=Flatten[PromoteOtherIdentities/@M,1]


SolveGroebnerBasis[m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{targets,denominator,numerator},
targets=Cases[Flatten[Outer[List,groebnerBasis,variables,1],1],{polynomial_,variable_}/;Exponent[polynomial,variable]==1];
If[Length[targets]==0,
{m},
SolvePolynomial[targets[[1,1]],targets[[1,2]]][m]
]
]
SolveGroebnerBasis[M_List]:=Flatten[SolveGroebnerBasis/@M,1]


SolvePolynomial[p_,v_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{numerator,denominator},
Print["solving for ",v];
numerator=-(p/.v->0);
denominator=Coefficient[p,v];
Flatten[
{
Print["considering the case where the coefficients ",{numerator,denominator}," vanish separately"];VerifyNonzero[nonzeroPolynomials][DeclarePolynomialsZero[{numerator,denominator}][m],m],
Print["adding the substitution ",v->Factor[numerator/denominator]];
VerifyNonzero[nonzeroPolynomials][AddSubstitution[v->Factor[numerator/denominator]][DeclarePolynomialNonZero[denominator][m]],m]
},1]
]


AddIrreduciblePolynomialToOtherIdentities[polynomial_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{},
VerifyNonzero[nonzeroPolynomials][SolveOtherIdentities[Manifold[substitutions,groebnerBasis,Union[otherIdentities~Join~{polynomial}],nonzeroPolynomials,variables]],m]
]


SolveOtherIdentities[m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{variables1,variables2,targets},
variables1 =Union[Cases[otherIdentities,tt[_],\[Infinity]]];
targets=Cases[Flatten[Outer[List,otherIdentities,variables1,1],1],{polynomial_,variable_}/;Exponent[polynomial,variable]==1\[And]mustBeNonZeroQ[m,Coefficient[polynomial,variable]]];
If[Length[targets]==0,
variables2=Union[Cases[otherIdentities,Subscript[p, _],\[Infinity]]];
targets=Cases[Flatten[Outer[List,otherIdentities,variables2,1],1],{polynomial_,variable_}/;Exponent[polynomial,variable]==1\[And]mustBeNonZeroQ[m,Coefficient[polynomial,variable]]];
targets=SortBy[targets,-diagramWeight[NamedPolyhedron[#[[2]]]]&];
];
If[Length[targets]==0,
{m},
SolveOtherIdentities[VerifyNonzero[nonzeroPolynomials][AddSubstitution[targets[[1,2]]->Factor[Solve[targets[[1,1]]==0,targets[[1,2]]][[1,1,2]]]][Manifold[substitutions,groebnerBasis,DeleteCases[otherIdentities,targets[[1,1]]],nonzeroPolynomials,variables]],m]]
]
]

SolveOtherIdentities[M_List]:=Flatten[SolveOtherIdentities/@M,1]


mustBeNonZeroQ[m:_[_List,_List,_List,nonzeroPolynomials_List,_List],polynomial_]:=Module[{factors},
(*Print["mustBeNonZeroQ: ",polynomial];*)
factors=Cases[withoutMultiplicity/@timesToList[Factor[ReducePolynomials[m][polynomial]]],{f_,k_}/;k>0:>f];
(*Print["factors: ",factors];*)
If[factors==={0},
False,
factors=DeleteCases[factors,_Integer|_Rational|_AlgebraicNumber];
factors=Complement[factors,nonzeroPolynomials~Join~(-nonzeroPolynomials)];
(*Print["factors: ",factors];*)
(*If[Length[factors]>1,
Print[m]
];*)
Length[factors]==0
]
]


Clear[AddSubstitution]
AddSubstitution[substitution:(_->_)][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{newGroebnerBasis,newSubstitutions,newOtherIdentities,newNonzeroPolynomials,newManifold},
If[MemberQ[substitutions,substitution],{m},
newGroebnerBasis=cachedGroebnerBasis[Numerator[Together[groebnerBasis/.substitution]],variables];
If[MemberQ[newGroebnerBasis,1|-1],{},
(* this is a shocking mess, trying to make sure we keep around all the nonzero polynomials correctly *)
newNonzeroPolynomials=Union[Factor[(cachedRationalFunctionReduce[Together[#/.substitution],newGroebnerBasis,variables]&/@nonzeroPolynomials)]];
newNonzeroPolynomials=Factor[Union[newNonzeroPolynomials,Flatten[Cases[withoutMultiplicity/@timesToList[Factor[#]],{f_,k_}:>f]&/@newNonzeroPolynomials]]];
If[MemberQ[newNonzeroPolynomials,0],{},
newOtherIdentities=DeleteCases[Expand[cachedPolynomialReduce[Numerator[Together[#/.substitution]],newGroebnerBasis,variables][[2]]&/@otherIdentities],0];
newManifold=Manifold[substitutions,newGroebnerBasis,newOtherIdentities,DeleteCases[newNonzeroPolynomials,_?NumericQ],variables];
newSubstitutions=Function[{subst},
(*Print["updating substitution: ",subst];*)subst[[1]]->ReducePolynomials[newManifold][subst[[2]]]]/@Together[Sort[(substitutions/.substitution)~Join~{substitution}]];
newManifold=ReplacePart[newManifold,1->newSubstitutions];
newNonzeroPolynomials=Union[newNonzeroPolynomials,Factor[ReducePolynomials[newManifold][nonzeroPolynomials]]];
newNonzeroPolynomials=Union[newNonzeroPolynomials,Flatten[Cases[withoutMultiplicity/@timesToList[Factor[#]],{f_,k_}:>f]&/@newNonzeroPolynomials]];
If[MemberQ[newNonzeroPolynomials,0],
Print["The substitution ",substitution," would render a nonzero quantity zero, so we reject this possibility."];
{},
newManifold=ReplacePart[newManifold,-2->DeleteCases[newNonzeroPolynomials,_?NumericQ]];
(* TODO what other processing has to happen afterwards? *)
VerifyNonzero[nonzeroPolynomials][FactorGroebnerBasis[SolveOtherIdentities[SolveGroebnerBasis[PromoteOtherIdentities[VerifyNonzero[nonzeroPolynomials][{newManifold},m]]]]],newManifold]
]
]
]
]
]
automaticFlatMap[AddSubstitution]


DeclarePolynomialsNonZero[p_List][m_Manifold]:=Fold[DeclarePolynomialNonZero[#2][#1]&,{m},p]


DeclarePolynomialNonZero[1|-1][m_Manifold]:={m}


DeclarePolynomialNonZero[p_][m_Manifold]:=Module[{factors},
factors=Complement[DeleteCases[Cases[withoutMultiplicity/@timesToList[Factor[p]],{f_,k_}/;k>0:>f],1|-1],m[[3]]~Join~(-m[[3]])];
If[Length[factors]>0,
text["We find the factors " ,factors," and then require that each is nonzero."]
];
DeclareIrreduciblePolynomialNonZero[Numerator[Together[p]]][Fold[DeclareIrreduciblePolynomialNonZero[#2][#1]&,{m},factors]]
]


DeclareIrreduciblePolynomialNonZero[polynomial_][m:Manifold[substitutions_List,groebnerBasis_List,otherIdentities_List,nonzeroPolynomials_List,variables_List]]:=Module[{reduced,variables0},
variables0=Union[Cases[groebnerBasis,Subscript[p, _]|tt[_],\[Infinity]]]~Join~variables;
reduced=ReducePolynomials[m][polynomial];
If[reduced===0,
text["Since ",polynomial, " is zero modulo the ideal, we terminate the analysis here."];
{},
(*text["We add ",reduced," to the list of nonzero quantities."];*)
VerifyNonzero[nonzeroPolynomials][SolveOtherIdentities[{Manifold[substitutions,groebnerBasis,otherIdentities,Union[nonzeroPolynomials~Join~DeleteCases[{reduced},_?NumericQ]],variables]}],m]]
]


Clear[buildSpiderAnalysis]
buildSpiderAnalysis[
spider_?JavaObjectQ/;InstanceOf[spider,"net.tqft.toolkit.algebra.spiders.examples.QuotientSpider"],
manifold_Manifold,
dimensionBounds:{{_Integer,_Integer|\[Infinity]}..},
independentDiagrams:{Diagram...},
dependentDiagrams:{Diagram...},
closedDiagrams:{Diagram...},
spanningSets:{{{Diagram...}...}...},
reducingRelations:{(Diagram->{(Diagram->_)...})...},
nonReducingRelations:{{(Diagram->_)..}...}]:=SpiderAnalysis[spider,manifold,dimensionBounds,independentDiagrams,dependentDiagrams,closedDiagrams,spanningSets,reducingRelations,nonReducingRelations]


Format[SpiderAnalysis[spider_,manifold_,dimensionBounds_,independentDiagrams_,dependentDiagrams_,closedDiagrams_,spanningSets_,reducingRelations_,nonReducingRelations_]]:="SpiderAnalysis"[spider,manifold,dimensionBounds,Short[independentDiagrams],Short[dependentDiagrams],Short[closedDiagrams],spanningSets,Short[reducingRelations],Short[nonReducingRelations]]


DimensionBounds[s_SpiderAnalysis]:=s[[3]]
DimensionBounds[s_SpiderAnalysis,k_Integer]:=Module[{bounds=DimensionBounds[s]},
If[Length[bounds]<k+1,{0,\[Infinity]},bounds[[k+1]]]
]


DimensionLowerBound[s_SpiderAnalysis,k_Integer]:=DimensionBounds[s,k][[1]]
DimensionUpperBound[s_SpiderAnalysis,k_Integer]:=DimensionBounds[s,k][[2]]


IndependentDiagrams[k_Integer][s_SpiderAnalysis]:=Cases[s[[4]],d_/;d@numberOfBoundaryPoints[]==k]
DependentDiagrams[k_Integer][s_SpiderAnalysis]:=Cases[s[[5]],d_/;d@numberOfBoundaryPoints[]==k]
SpanningSets[k_Integer][s_SpiderAnalysis]:=If[Length[s[[7]]]<k+1,{},s[[7,k+1]]]
ReducingRelations[k_Integer][s_SpiderAnalysis]:=Cases[s[[8]],l_/;l[[2,1,2]]@numberOfBoundaryPoints[]==k]
ReducibleDiagrams[s_SpiderAnalysis]:=s[[8,All,2,-1,2]]
NonReducingRelations[k_Integer][s_SpiderAnalysis]:=Cases[s[[9]],l_/;l[[1,2]]@numberOfBoundaryPoints[]==k]


AppendIndependentDiagram[d0:Diagram][s_SpiderAnalysis]:=ReplacePart[s,4->s[[4]]~Join~{d0}]


AppendDependentDiagram[d0:Diagram][s_SpiderAnalysis]:=ReplacePart[s,5->s[[5]]~Join~{d0}]


AppendClosedDiagram[d0:Diagram][s_SpiderAnalysis]:=ReplacePart[s,6->Union[s[[6]]~Join~{d0}]]


automaticFlatMap/@{AppendIndependentDiagram,AppendDependentDiagram,AppendClosedDiagram};


ReducedDiagrams[s_SpiderAnalysis,circumference_Integer,numbersOfVertices___Integer]:=FromScalaObject[s[[1]]@reducedDiagrams[circumference,AsScalaObject[Rule@@#&/@Transpose[{#@U1[]&/@FromScalaObject[s[[1]]@generators[],1],{numbersOfVertices}}]]],1]


TrivalentQ[s_SpiderAnalysis]:=s[[1]]@generators[]@size[]==1\[And]FromScalaObject[s[[1]]@generators[],1][[1]]@U1[]@perimeter[]==3\[And]FromScalaObject[s[[1]]@generators[],1][[1]]@U1[]@allowedRotationStep[]==1


ReducedDiagrams[s_SpiderAnalysis,circumference_Integer,numberOfVertices_Integer]/;TrivalentQ[s]:=
If[OddQ[numberOfVertices-circumference],{},
Module[{withFaces,result={},f},
withFaces[n_]:=withFaces[n]=
Cases[FromScalaObject[ScalaSingleton["net.tqft.toolkit.algebra.spiders.BoundaryConnectedPlanarGraphs"]@apply[circumference,n,Spiders`Private`AsScalaList[ReducibleDiagrams[s]]]@toList[],1],d_/;d@numberOfInternalVertices[]==numberOfVertices];
f=Max[1+(numberOfVertices-circumference)/2,0];
While[Length[withFaces[f]]>0,result=result~Join~withFaces[f];f++];
result
]
]


(* TODO add support for declaring dimension bounds "after the fact"? *)


DeclareDimensionBounds[bounds:{__Integer}][s_SpiderAnalysis]:=DeclareDimensionBounds[ReplacePart[Transpose[{bounds,bounds}],{-1,1}->0]][s]
DeclareDimensionBounds[bounds:{{_Integer,_Integer|\[Infinity]}..}][s_SpiderAnalysis]:=ReplacePart[s,3->bounds]
DeclareDimensionBounds[bounds_][S_List]:=DeclareDimensionBounds[bounds]/@S


FreeSpider[vertices:{{_Integer, _Integer,_Integer,_}...}]:=ScalaCaseClass["net.tqft.toolkit.algebra.spiders.examples.QuotientSpider",AsScalaObject[ScalaCaseClass["net.tqft.toolkit.algebra.spiders.VertexType",#[[1]],#[[2]],#[[3]]]->AsScalaObject[#[[4]],"MultivariableRationalFunction"]&/@vertices]@toSeq[],AsScalaList[{}]]


emptySpiderAnalysis[spider_,variables_]:=buildSpiderAnalysis[spider,Manifold[{},{},{},{},variables],{{1,1},{0,0},{1,1}},{},{},{},{},{},{}]


internalValences[diagram_]:=Length/@FromScalaObject[diagram@vertexFlags[]@tail[]]


If[Length[DownValues[diagramWeight]]==0,
diagramWeight[diagram_]:=Count[internalValences[diagram],3]+4Count[internalValences[diagram],4]
]


EvaluateDiagram[s_SpiderAnalysis][d0:Diagram]:=DrawPlanarGraph[#@U1[]]->ReducePolynomials[s][FromScalaObject[#@U2[]]]&/@FromScalaObject[s[[1]]@canonicalForm[AsScalaMap[{d0->AsScalaObject[1,"MultivariableRationalFunction"]}]],1]


EvaluateClosedDiagram[s_SpiderAnalysis][d0:Diagram]:=ReducePolynomials[s][FromScalaObject[s[[1]]@evaluate[s[[1]]@canonicalForm[AsScalaMap[{d0->AsScalaObject[1,"MultivariableRationalFunction"]}]]]]]


ClosedDiagrams[s_SpiderAnalysis]:=s[[6]]


ConsiderClosedDiagram[d0:Subscript[p, _]]:=ConsiderClosedDiagram[NamedPolyhedron[d0]]
ConsiderClosedDiagram[d0:Diagram][s_SpiderAnalysis]:=Module[{evaluations},
If[MemberQ[#@hashCode[]&/@ClosedDiagrams[s],d0@hashCode[]],
{s},
Print["Considering a new closed diagram: ",DrawPlanarGraph[d0]];
Print[s[[1]]@evaluate[AsScalaObject[{d0->Ring@one[]}]]@toString[]];
evaluations=FromScalaObject[s[[1]]@allOneStepEvaluations[d0]@toSeq[]];
Print["evaluations, before reducing: ",evaluations];
evaluations=ReducePolynomials[s][evaluations];
Print["evaluations, after reducing: ",evaluations];
Print["Finished evaluating ..."];
DeclarePolynomialsZero[DeleteCases[Union[Last[evaluations]-#&/@Most[evaluations]],0]][ConsiderClosedDiagrams[NamedPolyhedron/@Union[Cases[evaluations,Subscript[p, _Integer],\[Infinity]]]][
AppendClosedDiagram[d0][s]]
]
]
]


ConsiderClosedDiagrams[diagrams_List][s_SpiderAnalysis]:=Fold[ConsiderClosedDiagram[#2][#1]&,{s},diagrams]



Clear[cachedInnerProduct]
cachedInnerProduct[spiderHash_,x_String,y_String]:=$Failed


rotationFactor[s_SpiderAnalysis,rotations:{{_Integer,_Integer}...}]:=Times@@(rotationFactor[s,#]&/@rotations)
rotationFactor[s_SpiderAnalysis,rotation:{p_Integer,c_Integer}]:=Module[{vertices},
vertices=Cases[FromScalaObject[s[[1]]@generators[],2],({v_,w_}/;v@perimeter[]==p):>FromScalaObject[w]];
If[Length[vertices]!=1,
Print["Ask Scott to go implement rotations properly; for now you can't have two vertices with the same valence, but different eigenvalues."];
Abort[]
];
vertices[[1]]^c
]


cachingInnerProduct[spider_SpiderAnalysis,x:Diagram,y:Diagram]:=cachingInnerProduct[spider,x@toString[],y@toString[]]
cachingInnerProduct[s_SpiderAnalysis,x_String,y_String]:=Module[{xs,ys,outerHash,innerHash,result},
outerHash=Hash[s];
innerHash=s[[1]]@hashCode[];
result=cachedInnerProduct[outerHash,x,y];
If[result===$Failed,
result=cachedInnerProduct[innerHash,x,y];
If[result===$Failed,
result=cachedInnerProduct[innerHash,x,y]=
Module[{ip},
ip=PlanarGraphs@spider[]@innerProduct[PlanarGraphs@fromString[x],PlanarGraphs@fromString[y]]@canonicalFormWithDefect[];
rotationFactor[s,FromScalaObject[ip@U2[]@vertexRotations[]]]cachingEvaluation[s[[1]],ip@U1[]]
]
(*FromScalaObject[spider\[LeftDoubleBracket]1\[RightDoubleBracket]@innerProductMatrix[Spiders`Private`AsScalaList[{PlanarGraphs@fromString[x]}],Spiders`Private`AsScalaList[{PlanarGraphs@fromString[y]}]]]\[LeftDoubleBracket]1,1\[RightDoubleBracket];*)
];
result=cachedInnerProduct[outerHash,x,y]=ReducePolynomials[s][result];
];
result
]


cachedEvaluation[hash_,xs_String]:=$Failed
cachingEvaluation[spider_?JavaObjectQ,x:Diagram]:=Module[{hash,result,xs},
xs=x@toString[];
hash=spider@hashCode[];
result=cachedEvaluation[hash,xs];
If[result===$Failed,
result=cachedEvaluation[hash,xs]=FromScalaObject[spider@evaluate[spider@replaceRepeatedly[spider@reductions[],AsScalaMap[{x->AsScalaObject[1,"MultivariableRationalFunction"]}]]]];
];
result
]


cachingInnerProduct[spider_SpiderAnalysis,xs_List]:=cachingInnerProduct[spider,xs,xs]
cachingInnerProduct[spider_SpiderAnalysis,xs_List,ys_List]:=Outer[cachingInnerProduct[spider,##]&,xs,ys]


Clear[ConsiderPotentialSpanningSet]
ConsiderPotentialSpanningSet[diagrams:{Diagram...}]:=ConsiderPotentialSpanningSet[diagrams[[1]]@numberOfBoundaryPoints[],diagrams]
(*ConsiderPotentialSpanningSet[k_Integer,diagrams:{Diagram...}][s_SpiderAnalysis]:=Module[{zzz,innerProducts,subsets,det,determinants},
If[Length[s\[LeftDoubleBracket]7\[RightDoubleBracket]]<k+1,
ConsiderPotentialSpanningSet[k,diagrams][ReplacePart[s,7\[Rule](PadRight[s\[LeftDoubleBracket]7\[RightDoubleBracket],k+1,zzz]/.zzz\[Rule]{})]],
If[Length[SpanningSets[k][s]]>0,
Print["There's already a declared spanning set for ", k, " boundary points"];Abort[],
Flatten[{
(* either it's a spanning set *)
Print["Declaring that ",DrawPlanarGraph/@diagrams, " is a spanning set"];
{ReplacePart[s,7\[Rule]ReplacePart[s\[LeftDoubleBracket]7\[RightDoubleBracket],k+1\[Rule]{diagrams}]]},
(* or it's not *)
If[Length[diagrams]\[GreaterEqual]DimensionUpperBound[s,k],
(* the determinant must vanish! *)
Print["Declaring that ",#@toString[]&/@diagrams, " does not span, and hence that its matrix of inner products must vanish."];
innerProducts=cachingInnerProduct[s,diagrams];
subsets=Subsets[Range[Length[diagrams]],{DimensionUpperBound[s,k]}];
det[{}]=1;
det[m_]:=delegatingDeterminant[m];
determinants =Union[ReducePolynomials[s][det[innerProducts\[LeftDoubleBracket]#,#\[RightDoubleBracket]]]&/@subsets];
Print["determinants: ",determinants];
DeclarePolynomialsZero[determinants][s],
Print["Be careful: you've proposed a spanning set that isn't as big as the dimension bound you're interested in!"];Abort[];
{s}
]
},1]
]
]
]*)
automaticFlatMap[ConsiderPotentialSpanningSet]


ConsiderPotentialSpanningSet[k_Integer,diagrams:{Diagram...}][s_SpiderAnalysis]:=Module[{zzz,s0,innerProducts,subsets,det,determinants,gcd},
If[Length[s[[7]]]<k+1,
ConsiderPotentialSpanningSet[k,diagrams][ReplacePart[s,7->(PadRight[s[[7]],k+1,zzz]/.zzz->{})]],
If[Length[SpanningSets[k][s]]>0,
Print["There's already a declared spanning set for ", k, " boundary points"];Abort[],
innerProducts=cachingInnerProduct[s,diagrams];
det[{}]=1;
det[m_]:=Factor[delegatingDeterminant[m]];
Flatten[{
(* either it's a spanning set *)
Print["Declaring that ",DrawPlanarGraph/@diagrams, " is a spanning set"];
s0=ReplacePart[s,{{3,k+1,2}->Min[s[[3,k+1,2]],Length[diagrams]],7->ReplacePart[s[[7]],k+1->{diagrams}]}];
If[s0[[3,k+1,2]]<s0[[3,k+1,1]],{},
If[Sum[Binomial[Length[diagrams],m],{m,Range@@DimensionBounds[s,k]}]>20,
Print["Warning, computing many determinants. Did you forget to set a lower bound on the dimension?"];
];
subsets=Subsets[Range[Length[diagrams]],DimensionBounds[s,k]];
Print["subsets: ",Length[subsets]];
determinants =ReducePolynomials[s][det[innerProducts[[#,#]]]]&/@subsets;
gcd=PolynomialGCD@@determinants;
DeclarePolynomialNonZero[gcd][s0]
(*
We should be able to do the following, but it seems it's too slow.
*)
(*;
subsets=Subsets[Range[Length[diagrams]],{DimensionUpperBound[s,k]+1}];
determinants =Union[ReducePolynomials[s][det[innerProducts\[LeftDoubleBracket]#,#\[RightDoubleBracket]]]&/@subsets];
Print["determinants: ",determinants];
DeclarePolynomialsZero[determinants][DeclarePolynomialNonZero[gcd][s0]]*)

]
,
(* or it's not *)
(* determinants must vanish! *)
Print["Declaring that ",DrawPlanarGraph/@diagrams, " does not span, and hence that some determinants of inner products must vanish."];
subsets=Subsets[Range[Length[diagrams]],{DimensionUpperBound[s,k]}];
determinants =Union[ReducePolynomials[s][det[innerProducts[[#,#]]]]&/@subsets];
Print["determinants: ",determinants];
(* no idea what this next line was here for: seems wrong *)
(*s0=Flatten[{
DeclarePolynomialZero[det[innerProducts]][s],
DeclarePolynomialNonZero[det[innerProducts]][ReplacePart[s,{3,k+1,1}\[Rule]Max[s\[LeftDoubleBracket]3,k+1,1\[RightDoubleBracket],Length[diagrams]+1]]]
},1];*)
s0=DeclarePolynomialsZero[determinants][s]
},1]
]
]
]


DeclareSpanningSet[diagrams:{Diagram...}]:=DeclareSpanningSet[diagrams[[1]]@numberOfBoundaryPoints[],diagrams]
DeclareSpanningSet[k_Integer,diagrams:{Diagram...}][s_SpiderAnalysis]:=Module[{zzz},
If[Length[s[[7]]]<k+1,
DeclareSpanningSet[k,diagrams][ReplacePart[s,7->(PadRight[s[[7]],k+1,zzz]/.zzz->{})]],
{ReplacePart[s,7->ReplacePart[s[[7]],k+1->{diagrams}]]}
]
]
automaticFlatMap[DeclareSpanningSet]


DeclareBasis[diagrams:{Diagram...}]:=DeclareBasis[diagrams[[1]]@numberOfBoundaryPoints[],diagrams]
DeclareBasis[k_Integer,diagrams:{Diagram...}][s_SpiderAnalysis]:=Module[{pairings,innerProducts,det,s0},
pairings=
DeleteCases[Flatten[Table[ComputePairingsWithReducingRelations[d0][s]~Join~ComputePairingsWithNonReducingRelations[d0][s],{d0,diagrams}]],0];
If[Length[pairings]>0,
DeclareBasis[diagrams][DeclarePolynomialsZero[Numerator[Together[pairings]]][s]],
If[DimensionLowerBound[s,k]<=Length[diagrams]<=DimensionUpperBound[s,k],
innerProducts=cachingInnerProduct[s,diagrams];
det[{}]=1;
det[m_]:=Factor[delegatingDeterminant[m]];
s0=ReplacePart[s,{3,k+1}->{Length[diagrams],Length[diagrams]}];
s0=DeclareSpanningSet[k,diagrams][s0];
s0=Fold[AppendIndependentDiagram[#2][#1]&,s0,diagrams];
DeclarePolynomialNonZero[det[innerProducts]][s0]
,
{}]
]
]
automaticFlatMap[DeclareBasis]


Clear[ConsiderDiagrams]
ConsiderDiagrams[diagrams:{Diagram...},options:(_String->(True|False))...]:=ConsiderDiagrams[diagrams[[1]]@numberOfBoundaryPoints[],diagrams,options]
(*ConsiderDiagrams[k_Integer,diagrams:{Diagram...},options:(_String\[Rule](True|False))...][s_SpiderAnalysis]:=If[Length[SpanningSets[k][s]]\[Equal]0,
Fold[ConsiderDiagram[#2,options][#1]&,ConsiderPotentialSpanningSet[k,diagrams][s],diagrams],
Fold[ConsiderDiagram[#2,options][#1]&,{s},diagrams]
]*)
ConsiderDiagrams[k_Integer,diagrams:{Diagram...},options:(_String->(True|False))...][s_SpiderAnalysis]:=
Module[{},
(* a global variable, blech *)
consideringDiagrams=diagrams;
Fold[ConsiderDiagram[#2,options][#1]&,{s},diagrams]
]
automaticFlatMap[ConsiderDiagrams]


(*ConsiderDiagrams[diagrams:{Diagram...},options:(_String\[Rule](True|False))...][s_SpiderAnalysis]:=Fold[PairRelationsWith[Drop[diagrams,#2\[LeftDoubleBracket]2\[RightDoubleBracket]]][ConsiderDiagram[#2\[LeftDoubleBracket]1\[RightDoubleBracket],options][#1]]&,{s},Transpose[{diagrams,Range[Length[diagrams]]}]]*)


ReconsiderClosedDiagrams[s_SpiderAnalysis]:=ConsiderClosedDiagrams[ClosedDiagrams[s]][ReplacePart[s,6->{}]]
ReconsiderClosedDiagrams[S_List]:=Flatten[ReconsiderClosedDiagrams/@S]


ConsiderDiagram[d0:Diagram,options:(_String->(True|False))...][s_SpiderAnalysis]:=Module[{k,closedDiagrams,pairings,secondPass,insistIndependent,insistDependent},
k=d0@numberOfBoundaryPoints[];
If[memberQDiagrams[IndependentDiagrams[k][s]~Join~DependentDiagrams[k][s],d0],{s},
(*If[Length[SpanningSets[k][s]]\[Equal]0,
Print["You need to declare a spanning set before we can consider diagrams..."];Abort[],*)
(*closedDiagrams=s\[LeftDoubleBracket]1\[RightDoubleBracket]@diagramSpider[]@innerProduct[d,#]@canonicalFormWithDefect[]@U1[]&/@({d}~Join~IndependentDiagrams[k][s]~Join~DependentDiagrams[k][s]);
closedDiagrams=Complement[{#@hashCode[],#}&/@closedDiagrams,{#@hashCode[],#}&/@ClosedDiagrams[s],SameTest->(First[#1] === First[#2] &)]\[LeftDoubleBracket]All,2\[RightDoubleBracket];*)
closedDiagrams={};
If[Length[closedDiagrams]>0,
Print["Found some new closed diagrams... trying all possible evaluations."];
ConsiderDiagram[d0,options][ConsiderClosedDiagrams[closedDiagrams][s]],
secondPass="SecondPass"/.{options}/."SecondPass"->False;
insistIndependent="InsistIndependent"/.{options}/."InsistIndependent"->False;
insistDependent=("InsistDependent"/.{options}/."InsistDependent"->False)||Length[IndependentDiagrams[k][s]]==DimensionUpperBound[s,k];
If[insistIndependent\[And]insistDependent,
Print["Warning: you've asked for this diagram to be independent, but we already have enough independent diagrams. Killing this branch."];{},
If[s[[1]]@reducibleDiagramU$qmark[d0],
{s},
If[!secondPass,
Print["We now consider the diagram ",DrawPlanarGraph[d0],If[insistIndependent,", insisting that it is independent.",If[insistDependent,", insisting that it is dependent.","."]]],
Print["We return to considering the diagram ",DrawPlanarGraph[d0],"."]
];
(*Put[PickleSpiderAnalysis[s],"/Users/scott/projects/toolkit/algebra-spiders/src/main/mathematica/saved-states/last.m"];
Global`lastDiagram=d0;*)
pairings=If[
memberQDiagrams[Flatten[SpanningSets[k][s]],d0],
{},
ComputePairingsWithReducingRelations[d0][s]~Join~ComputePairingsWithNonReducingRelations[d0][s]
];
If[Length[pairings]>0,
ConsiderDiagram[d0,"SecondPass"->True,"InsistIndependent"->insistIndependent,"InsistDependent"->insistDependent][DeclarePolynomialsZero[Numerator[Together[pairings]]][s]],
If[!insistDependent,
If[!insistIndependent,
Print["We consider separately the possibilities that it is linearly independent or linearly dependent."];
ConsiderIndependentDiagram[d0][s]~Join~ConsiderDependentDiagram[d0][s],
ConsiderIndependentDiagram[d0][s]
],
ConsiderDependentDiagram[d0][s]
]
]
]
]
]
]
]



PairRelationsWith[d0:Diagram][s_SpiderAnalysis]:=Module[{pairings},
pairings=ComputePairingsWithReducingRelations[d0][s]~Join~ComputePairingsWithNonReducingRelations[d0][s];
(*Print["d0: ",DrawPlanarGraph[d0]];
Print["pairings: ",pairings];*)
If[Length[pairings]>0,
DeclarePolynomialsZero[Numerator[Together[pairings]]][s],
{s}
]
]


PairRelationsWith[diagrams_List][s_SpiderAnalysis]:=Fold[PairRelationsWith[#2][#1]&,{s},diagrams]


automaticFlatMap/@{ConsiderDiagram,ConsiderDiagrams,ConsiderClosedDiagram,ConsiderClosedDiagrams,PairRelationsWith};


Clear[ReducePolynomials]


ReducePolynomials[s_SpiderAnalysis]:=ReducePolynomials[s[[2]]]


ReducePolynomials[m_Manifold][X_List]:=ReducePolynomials[m][#]&/@X


ReducePolynomials[m_Manifold][X:Diagram]:=X


ReducePolynomials[m_][X_]:=Module[{X0,f,variables},
X0=withoutMultiplicity/@timesToList[Factor[X/.m[[1]]]];
variables=Union[Cases[{m,X0},Subscript[p, _]|tt[_],\[Infinity]]]~Join~m[[5]];
f[{q_,k_}]:=Factor[cachedPolynomialReduce[q,m[[2]],variables][[2]]]^k;
Times@@(f/@X0)
]


ReducePolynomialsFurther[s_SpiderAnalysis]:=ReducePolynomialsFurther[s[[2]]]


ReducePolynomialsFurther[m_Manifold][X_List]:=ReducePolynomialsFurther[m][#]&/@X


ReducePolynomialsFurther[m_Manifold][X_]:=Module[{X0,f,variables,result},
X0=withoutMultiplicity/@timesToList[Factor[X/.m[[1]]]];
variables=Union[Cases[{m,X0},Subscript[p, _]|tt[_],\[Infinity]]]~Join~m[[5]];
f[{q_,k_}]:=Factor[cachedPolynomialReduce[q,m[[2]]~Join~m[[3]],variables][[2]]]^k;
result=Times@@(f/@X0);
If[NumericQ[result],result=RootReduce[result]];
result
]


ComputePairingsWithReducingRelations[d0:Diagram][s_SpiderAnalysis]:=Module[{relations,innerProducts,oldSpider,relation},
relations=ReducingRelations[d0@numberOfBoundaryPoints[]][s];
(*Print["reducing relations: ",relations];*)
innerProducts=Flatten[Function[{pair},
{oldSpider,relation}=pair;
ReducePolynomials[s][{Plus@@(relation/.{z_,c:Diagram}:>z (cachingInnerProduct[ReplacePart[s,1->oldSpider],c,d0])),Plus@@(relation/.{z_,c:Diagram}:>z (cachingInnerProduct[s,c,d0]))}]
]/@relations];
Print[innerProducts];
DeleteCases[ReducePolynomialsFurther[s][innerProducts],0]
]


ComputePairingsWithNonReducingRelations[d0:Diagram][s_SpiderAnalysis]:=Module[{relations},
relations=NonReducingRelations[d0@numberOfBoundaryPoints[]][s];
(*Print["non-reducing relations: ",relations];*)
DeleteCases[ReducePolynomialsFurther[s][Plus@@#&/@(relations/.{z_,c:Diagram}:>Module[{r},
r=cachingInnerProduct[s,c,d0];
(*Print["inner product of ",DrawPlanarGraph[c], " and ", DrawPlanarGraph[d0], " is ",r, " which evaluates to ",ReducePolynomialsFurther[s][r]];*)
r z]
)],0]
]


delegatingNullSpace[m_,options___]:=If[Length[m]>\[Infinity]\[And]Length[Variables[m]]>1,{SchwartzZippelNullSpace[m]},NullSpace[m,options]]
delegatingDeterminant[m_]:=If[Length[m]>10,GuessingPolynomials`Private`onDiskParallelDeterminant[m,IntegerString[Hash[m,"SHA1"],16,16]],Det[m]]


ConsiderIndependentDiagram[d0:Diagram][s_SpiderAnalysis]:=Module[{s0,s1,k,i,innerProducts,innerProducts2,det,nullSpace,spanningSet,reorderedSpanningSet,dot,j},
k=d0@numberOfBoundaryPoints[];
If[memberQDiagrams[IndependentDiagrams[k][s]~Join~DependentDiagrams[k][s],d0],{s},
s0=AppendIndependentDiagram[d0][s];
i=IndependentDiagrams[k][s0];
innerProducts=cachingInnerProduct[s0,i];
det=ReducePolynomials[s0][Factor[delegatingDeterminant[innerProducts]]];
If[Length[i]==DimensionUpperBound[s0,k],
s0=DeclarePolynomialNonZero[det][s0]
];
Flatten[{
(* Either the determinant is non-zero, and we can proceed happily *)
DeclarePolynomialNonZero[det][s0],
(* or it's zero, in which case we find the corresponding ghost relation, find the element of the spanning set that exorcises it, and make sure we consider that diagram next *)
s1=DeclarePolynomialZero[det][s0];
Flatten[Function[{ss},
Print["innerProducts: ",innerProducts];
nullSpace=If[Length[i]==1,{{1}},Factor[delegatingNullSpace[Most[innerProducts],"Method"->"OneStepRowReduction"]]];
(* FIXME worry about denominators!? *)
Print["nullSpace: ",nullSpace];
If[Length[nullSpace]!=1,Print["null space wasn't 1-dimensional! help!"];Abort[]];
spanningSet=unionDiagrams[Flatten[SpanningSets[k][ss]]~Join~consideringDiagrams];
reorderedSpanningSet=i~Join~complementDiagrams[spanningSet,i];
If[Length[reorderedSpanningSet]=!=Length[spanningSet],
Print["something is wrong with complementDiagrams"];
Print["spanning set: ",DrawPlanarGraph/@spanningSet];
Global`i=i;
Print["independent diagrams: ",DrawPlanarGraph/@i];
Print["reordering spanning set: ",DrawPlanarGraph/@complementDiagrams[spanningSet,i]];
Abort[]
];
(*Print["reorderedSpanningSet: ",DrawPlanarGraph/@reorderedSpanningSet];*)
innerProducts2=cachingInnerProduct[ss,reorderedSpanningSet,i];
Print["innerProducts2: ",innerProducts2];
dot=ReducePolynomials[ss][innerProducts2.nullSpace[[1]]];
If[Take[dot,Length[i]]=!=Table[0,{Length[i]}],
dot=ReducePolynomialsFurther[ss][dot]
];
If[Take[dot,Length[i]]=!=Table[0,{Length[i]}],
Print["something is messed up!"];
Print["innerProducts2: ",innerProducts2];
Print["dot: ",dot];
Print[ss[[2]]];
Print["i: ",DrawPlanarGraph/@i];
Abort[]];
If[dot===Table[0,{Length[reorderedSpanningSet]}],
If[Length[SpanningSets[k][ss]]==0,
Print["You need to declare a spanning set to proceed!"];Abort[]
];
Print["Successfully ruled out the possibility of a ghost relation!"];
{},
j=Position[dot,Except[0],1,1,Heads->False][[1,1]];
Print["dot: ",dot];
Print["j: ",j];
Print["Because of a ghost relation, we're about to consider ",reorderedSpanningSet[[j]]@toString[],", possibly out of order."];
(* FIXME think carefully about whether it is correct that we can assume this one is independent? *)
ConsiderDiagram[reorderedSpanningSet[[j]],"InsistIndependent"->True][ss]
]
]/@s1,1]
},1]
]
]


NullSpaceInPolynomialQuotient[matrix_?MatrixQ,ideal_,variables_]:=Module[{l,a,as,gb},
Print["computing null space of ",matrix, " mod ", ideal];
l=Length[matrix[[1]]];
as=Table[a[i],{i,1,l}];
gb=GroebnerBasis[ideal~Join~Together[matrix.as],as~Join~variables];
Print["gb: ",gb];
NullSpace[DeleteCases[gb,r_/;FreeQ[r,a[_Integer]]]/.a[i_]:>UnitVector[l,i]]
]


ConsiderDependentDiagram[d0:Diagram][s_SpiderAnalysis]:=Module[{k,i,innerProducts,det,det0,s0,nullSpace,newRelation,denominators,result={}},
k=d0@numberOfBoundaryPoints[];
If[memberQDiagrams[IndependentDiagrams[k][s]~Join~DependentDiagrams[k][s],d0],{s},
Print["considering the dependent diagram ",DrawPlanarGraph[d0]];
Print["manifold: ",s[[2]]];
i=IndependentDiagrams[k][s];
innerProducts=cachingInnerProduct[s,i~Join~{d0}];
Print["computed and reduced inner products."];
det0[{}]=1;
det0[M_]:=delegatingDeterminant[M];
(*If[ReducePolynomials[s][Factor[det0[Most[Most/@innerProducts]]]]===0,
Print["Something has gone wrong; the upper left minor should have nonzero determinant!"];
Print[s\[LeftDoubleBracket]2\[RightDoubleBracket]];
Print[innerProducts];
Print[Factor[Det[Most[Most/@innerProducts]]]];
Print[ReducePolynomials[s][Factor[det0[Most[Most/@innerProducts]]]]];
Message[foo::bar];
Abort[]
];
*)
innerProducts0=innerProducts;
det=det0[innerProducts];
Print["computed determinant"];
det=ReducePolynomials[s][det];
Print["reduced determinant"];
s0=DeclarePolynomialsZero[{det}][s];
Print["declared determinant zero"];
If[Length[s0]==0,
Print[DrawPlanarGraph[d0]," can't be dependent; the determinant of inner products isn't allowed to vanish"];
{},
nullSpace=If[Length[i]==0,
{{1}},
Factor[delegatingNullSpace[Most[innerProducts],"Method"->"OneStepRowReduction"]]
];
Print["computed null space"];
If[Length[nullSpace]=!=1,Print["Found a null space that wasn't 1-dimensional: ",nullSpace];Abort[]];
newRelation=Factor[nullSpace[[1]]];
If[newRelation[[-1]]===0,
Print["The only possible relation is ",newRelation,", but that only involves diagrams which we've already declared independent."];
Print["innerProducts: ",innerProducts];
Abort[],
Print["We find a candidate relation ",newRelation];
denominators=Complement[Union[withoutMultiplicity[#][[1]]&/@Flatten[timesToList/@Factor[DeleteCases[Denominator/@newRelation,1|-1]]]],s[[2,4]]~Join~(-s[[2,4]])];
If[Length[denominators]>0,
denominators=ReducePolynomials[s[[2]]][denominators];
If[MemberQ[denominators,0],
Print["That null space calculation was bogus: bad denominators!"];
Print["Groebner basis: ",s[[2,2]]];
Print["nonzero stuff: ",s[[2,4]]];
Print["inner products: ",innerProducts];
Print["det: ",det];
Abort[]];
Print["This has denominators, ",denominators,", and we first consider the possibility that one of these vanishes."];
result=ConsiderDependentDiagram[d0][DeclareAtLeastOnePolynomialZero[denominators][s0]];
];
result~Join~PairRelationsWith[complementDiagrams[Flatten[SpanningSets[k][s]],Flatten[IndependentDiagrams[k][s]~Join~DependentDiagrams[k][s]]]][IntroduceRelation[k,Transpose[{newRelation,Append[i,d0]}]][AppendDependentDiagram[d0][DeclarePolynomialsNonZero[denominators][s0]]]]
]
]
]
]


automaticFlatMap/@{ConsiderIndependentDiagram,ConsiderDependentDiagram};


IntroduceRelation[relation:{{_,_:Diagram}..}]:=IntroduceRelation[relation[[1,2]]@numberOfBoundaryPoints[],relation]


IntroduceRelation[size_Integer,{}][s_SpiderAnalysis]:={s}


IntroduceRelation[size_Integer,relation:{terms___,{0,_}}]:=IntroduceRelation[size, {terms}]


IntroduceRelation[size_Integer,relation:{initialTerms___,{z_,diagram_}}][s_SpiderAnalysis]:=Module[{},
Print["As we are considering a relation with final coefficient not equal to one (",z,"), we branch into two cases, where that coefficient is zero or nonzero (and then divide through)."];
Flatten[IntroduceRelation[size,ReducePolynomials[#][relation]][#]&/@DeclarePolynomialZero[z][s],1]~Join~
IntroduceRelation[size,#/{z,1}&/@relation][DeclarePolynomialNonZero[z][s]]
]


IntroduceRelation[size_Integer,relation:{initialTerms___,{1,diagram_}}][s_SpiderAnalysis]:=Module[{diagrams,moreDiagrams,scalaRelation,innerProducts,nonzeroInnerProducts,newS},
diagrams=relation[[All,2]];
moreDiagrams=unionDiagrams[Flatten[Table[s[[1]]@diagramSpider[]@rotate[d0,k],{d0,unionDiagrams[diagrams~Join~DependentDiagrams[s[[1]]@diagramSpider[]@circumference[diagram]][s]~Join~IndependentDiagrams[s[[1]]@diagramSpider[]@circumference[diagram]][s]]},{k,0,s[[1]]@diagramSpider[]@circumference[d0]-1}]]];
Print["starting innerProductMatrix"];
innerProducts=cachingInnerProduct[s,diagrams,moreDiagrams];
nonzeroInnerProducts=Numerator[DeleteCases[ReducePolynomialsFurther[s][relation[[All,1]].innerProducts],0]];

(*
scalaRelation=AsScalaObject[#\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]AsScalaObject[#\[LeftDoubleBracket]1\[RightDoubleBracket],"MultivariableRationalFunction"]&/@relation];
innerProducts=Numerator[Together[FromScalaObject[s\[LeftDoubleBracket]1\[RightDoubleBracket]@allInnerProductEvaluations[scalaRelation,AsScalaList[moreDiagrams]]]]];
nonzeroInnerProducts=nonzeroInnerProducts~Join~Union[DeleteCases[ReducePolynomials[s][innerProducts],0]];
*)

Print["finished innerProductMatrix"];
If[Length[nonzeroInnerProducts]>0,
text["The candidate relation has non-trivial inner products with some of the diagrams appearing in it; we set these to zero first before proceeding."];
Print[innerProducts];
Print["declaring zero: ", nonzeroInnerProducts];
newS=DeclarePolynomialsZero[nonzeroInnerProducts][s];
Print[newS];
If[s===newS,Print[newS];Abort[]];
Flatten[IntroduceRelation[size,ReducePolynomials[#][relation]][#]&/@newS,1],
(* Decide if it is a reducing relation or not. *)
If[diagramWeight[diagram]>Max[diagramWeight[#]&/@Cases[{initialTerms},({z_,d_}/;z=!=0):>d]],
IntroduceReducingRelation[size,relation][s],
IntroduceNonReducingRelation[size,relation][s]
]
]
]


tCounter=1;


IntroduceReducingRelation[size_,relation:{initialTerms___,{1,diagram_}}][s_SpiderAnalysis]:=Module[{reduction,newSubstitutions},
text["We now add this relation to the set of reducing relations."];
newSubstitutions=(tt[tCounter++]->#)&/@{initialTerms}[[All,1]];
reduction=ScalaCaseClass["net.tqft.toolkit.algebra.spiders.Reduction",diagram,AsScalaMap[#[[2]]->AsScalaObject[-#[[1]],"MultivariableRationalFunction"]&/@({initialTerms}/.(Reverse/@newSubstitutions))]];
PairRelationsWith[IndependentDiagrams[size][s]~Join~DependentDiagrams[size][s]][Global`stash=ReconsiderClosedDiagrams[DeclarePolynomialsZero[Numerator[Together[#[[1]]-#[[2]]]]&/@newSubstitutions][ReplacePart[s,{1->s[[1]]@addReduction[reduction],-2->s[[-2]]~Join~{{s[[1]],relation}}}]]]]
]


IntroduceNonReducingRelation[size_,relation_][s_SpiderAnalysis]:=Module[{},
Print["Adding a non-reducing relations, but for the most part ignoring it!"];
ReplacePart[s,-1->s[[-1]]~Join~{relation}]
]


automaticFlatMap/@{IntroduceRelation,IntroduceReducingRelation,IntroduceNonReducingRelation};


DeclarePolynomialEitherZeroOrNonZero[polynomial_][s_SpiderAnalysis]:=Flatten[{DeclarePolynomialsZero[{polynomial}][s],DeclarePolynomialNonZero[polynomial][s]},1]


DeclarePolynomialZero[polynomial_][s_SpiderAnalysis]:=DeclarePolynomialsZero[{polynomial}][s]


DeclarePolynomialsZero[polynomials_List][s_SpiderAnalysis]:=Module[{newManifolds},
newManifolds=DeclarePolynomialsZero[polynomials][s[[2]]];
(* TODO should we look at the non-reducing relations and see if any became reducing?! *)
ReplacePart[s,2->#]&/@newManifolds
]


DeclareAtLeastOnePolynomialZero[polynomials_List][s_SpiderAnalysis]:=Module[{newManifolds},
newManifolds=DeclareAtLeastOnePolynomialZero[polynomials][s[[2]]];
(* TODO should we look at the non-reducing relations and see if any became reducing?! *)
ReplacePart[s,2->#](*/.(d:Diagram\[Rule]z_)\[RuleDelayed](d\[Rule]cachedPolynomialReduce[z,#\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]2\[RightDoubleBracket])*)&/@newManifolds
]


DeclarePolynomialsNonZero[polynomials_List][s_SpiderAnalysis]:=Module[{newManifolds},
newManifolds=DeclarePolynomialsNonZero[polynomials][s[[2]]];
ReplacePart[s,2->#](*/.(d:Diagram\[Rule]z_)\[RuleDelayed](d\[Rule]cachedPolynomialReduce[z,#\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]2\[RightDoubleBracket])*)&/@newManifolds
]


DeclarePolynomialNonZero[polynomial_][s_SpiderAnalysis]:=Module[{newManifolds},
newManifolds=DeclarePolynomialNonZero[polynomial][s[[2]]];
ReplacePart[s,2->#](*/.(d:Diagram\[Rule]z_)\[RuleDelayed](d\[Rule]cachedPolynomialReduce[z,#\[LeftDoubleBracket]1\[RightDoubleBracket]]\[LeftDoubleBracket]2\[RightDoubleBracket])*)&/@newManifolds
]
automaticFlatMap[DeclarePolynomialNonZero]


PickleSpiderAnalysis[s_SpiderAnalysis]:=Append[PickledSpiderAnalysis@@(s/.{d0:Diagram:>d0@toString[],q_?JavaObjectQ/;InstanceOf[q,"net.tqft.toolkit.algebra.spiders.examples.QuotientSpider"]:>PickleQuotientSpider[q]}),
{#,NamedPolyhedron[#]@toString[]}&/@Union[Cases[s,Subscript[p, _],\[Infinity]]]
]
PickleSpiderAnalysis[S_List]:=PickleSpiderAnalysis/@S


UnpickleSpiderAnalysis[s_PickledSpiderAnalysis]:=Module[{renamer},
tCounter=Max[tCounter,Union[Cases[s,tt[k_]:>k,\[Infinity]]]+1];
renamer[Subscript[p, k_]]:=renamer[Subscript[p, k]]=Cases[s[[-1]],{Subscript[p, k],r_}:>Name[PlanarGraphs@fromString[r]],1,1][[1]];SpiderAnalysis@@(Most[s]/.{Subscript[p, k_]:>renamer[Subscript[p, k]]}/.{d0_String/;StringTake[d0,12]==="PlanarGraph(":>PlanarGraphs@fromString[d0],q_PickledQuotientSpider:>UnpickleQuotientSpider[q]})
]
UnpickleSpiderAnalysis[S_List]:=UnpickleSpiderAnalysis/@S


PickleQuotientSpider[q_/;InstanceOf[q,"net.tqft.toolkit.algebra.spiders.examples.QuotientSpider"]]:=PickledQuotientSpider[
Flatten[{ToExpression["{"<>StringTake[#@U1[]@toString[],{12,-2}]<>"}"],FromScalaObject[#@U2[]]}]&/@FromScalaObject[q@generators[],1],
{#@big[]@toString[],FromScalaObject[#@small[]]}&/@FromScalaObject[q@extraReductions[],1]
]


UnpickleQuotientSpider[PickledQuotientSpider[generators_,reductions_]]:=Module[{scalaReductions},
scalaReductions=ScalaCaseClass["net.tqft.toolkit.algebra.spiders.Reduction",PlanarGraphs@fromString[#[[1]]],AsScalaMap[Function[{term},PlanarGraphs@fromString[term[[1]]]->AsScalaObject[term[[2]],"MultivariableRationalFunction"]]/@#[[2]]]]&/@reductions;
Fold[#1@addReduction[#2]&,FreeSpider[generators],scalaReductions]
]


End[];


EndPackage[];
